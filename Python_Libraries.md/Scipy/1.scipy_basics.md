# SciPy Basics - Simple Guide

## What is SciPy?
SciPy (Scientific Python) is a library for scientific computing. It builds on NumPy and provides tools for optimization, statistics, signal processing, and more.

## Installation
```python
pip install scipy
```

## Import SciPy
```python
import scipy
import numpy as np
```

## 1. Constants and Physical Units

### Mathematical Constants
```python
from scipy import constants

# Mathematical constants
print(constants.pi)        # 3.141592653589793
print(constants.e)         # 2.718281828459045
print(constants.golden)    # 1.618033988749895 (golden ratio)

# Physical constants
print(constants.c)         # Speed of light: 299792458.0 m/s
print(constants.h)         # Planck constant
print(constants.electron_mass)  # Electron mass in kg
print(constants.g)         # Gravitational acceleration: 9.80665 m/sÂ²
```

### Unit Conversions
```python
from scipy import constants

# Convert units
print(constants.liter)           # 0.001 (cubic meters)
print(constants.gram)            # 0.001 (kilograms)
print(constants.pound)           # 0.45359237 (kilograms)
```

## 2. Integration (Calculus)

### Simple Integration
```python
from scipy import integrate
import numpy as np

# Define a function
def f(x):
    return x**2

# Integrate from 0 to 2
result, error = integrate.quad(f, 0, 2)
print(f"Integral: {result}")      # 2.666...
print(f"Error: {error}")           # Very small error
```

### Integration with Parameters
```python
# Function with parameters
def f(x, a, b):
    return a * x + b

# Integrate with parameters
result, error = integrate.quad(f, 0, 1, args=(2, 3))
print(result)  # 4.0
```

### Multiple Integration
```python
# Double integral
def integrand(x, y):
    return x * y

# Integrate over rectangle [0,1] x [0,1]
result, error = integrate.dblquad(integrand, 0, 1, lambda x: 0, lambda x: 1)
print(result)  # 0.25
```

## 3. Optimization

### Finding Minimum
```python
from scipy.optimize import minimize

# Define function to minimize
def f(x):
    return (x - 3)**2 + 5

# Find minimum
result = minimize(f, x0=0)  # Start at x=0
print(f"Minimum at x = {result.x[0]}")      # x = 3.0
print(f"Minimum value = {result.fun}")       # 5.0
```

### Finding Roots (Zeros)
```python
from scipy.optimize import root, fsolve

# Define function
def f(x):
    return x**2 - 4

# Find root (where f(x) = 0)
result = root(f, x0=1)
print(f"Root: {result.x[0]}")  # 2.0 (or -2.0)

# Using fsolve (simpler)
root = fsolve(f, x0=1)
print(f"Root: {root[0]}")  # 2.0
```

### Curve Fitting
```python
from scipy.optimize import curve_fit
import numpy as np

# Define function to fit
def linear(x, a, b):
    return a * x + b

# Generate data with noise
x_data = np.linspace(0, 10, 20)
y_data = 2 * x_data + 3 + np.random.normal(0, 1, 20)

# Fit the curve
params, covariance = curve_fit(linear, x_data, y_data)
print(f"a = {params[0]:.2f}")  # Should be close to 2
print(f"b = {params[1]:.2f}")  # Should be close to 3
```

## 4. Interpolation

### 1D Interpolation
```python
from scipy.interpolate import interp1d
import numpy as np

# Sample data points
x = np.array([0, 1, 2, 3, 4, 5])
y = np.array([0, 2, 4, 6, 8, 10])

# Create interpolation function
f = interp1d(x, y, kind='linear')

# Interpolate at new points
x_new = np.array([1.5, 2.5, 3.5])
y_new = f(x_new)
print(y_new)  # [3. 5. 7.]
```

### Different Interpolation Methods
```python
# Linear interpolation
f_linear = interp1d(x, y, kind='linear')

# Cubic interpolation (smoother)
f_cubic = interp1d(x, y, kind='cubic')

# Use the smoother interpolation
y_smooth = f_cubic(x_new)
```

## 5. Statistics

### Descriptive Statistics
```python
from scipy import stats
import numpy as np

data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Basic statistics
print(stats.mean(data))      # Mean: 5.5
print(stats.median(data))    # Median: 5.5
print(stats.mode(data))      # Mode
print(stats.std(data))       # Standard deviation
print(stats.var(data))       # Variance
```

### Probability Distributions
```python
# Normal distribution
from scipy.stats import norm

# Create normal distribution (mean=0, std=1)
dist = norm(loc=0, scale=1)

# Probability density function (PDF)
pdf_value = dist.pdf(0)      # Value at x=0
print(f"PDF at 0: {pdf_value:.4f}")  # 0.3989

# Cumulative distribution function (CDF)
cdf_value = dist.cdf(1.96)   # Probability x < 1.96
print(f"CDF at 1.96: {cdf_value:.4f}")  # 0.9750

# Generate random samples
samples = dist.rvs(size=1000)  # 1000 random samples
```

### Hypothesis Testing
```python
from scipy.stats import ttest_1samp

# Sample data
data = np.array([1.2, 1.5, 1.8, 2.0, 1.9, 1.7, 1.6])

# One-sample t-test (test if mean = 1.5)
statistic, p_value = ttest_1samp(data, popmean=1.5)
print(f"t-statistic: {statistic:.4f}")
print(f"p-value: {p_value:.4f}")

# If p-value < 0.05, reject null hypothesis
if p_value < 0.05:
    print("Mean is significantly different from 1.5")
else:
    print("Mean is not significantly different from 1.5")
```

## 6. Linear Algebra

### Solving Linear Systems
```python
from scipy.linalg import solve
import numpy as np

# System: 3x + y = 9, x + 2y = 8
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

# Solve Ax = b
x = solve(A, b)
print(f"x = {x[0]:.2f}, y = {x[1]:.2f}")  # x = 2.00, y = 3.00
```

### Matrix Operations
```python
from scipy.linalg import inv, det, eig
import numpy as np

A = np.array([[1, 2], [3, 4]])

# Matrix inverse
A_inv = inv(A)
print("Inverse:\n", A_inv)

# Determinant
determinant = det(A)
print(f"Determinant: {determinant}")  # -2.0

# Eigenvalues and eigenvectors
eigenvalues, eigenvectors = eig(A)
print("Eigenvalues:", eigenvalues)
print("Eigenvectors:\n", eigenvectors)
```

## 7. Signal Processing

### Filtering Signals
```python
from scipy import signal
import numpy as np

# Create noisy signal
t = np.linspace(0, 1, 1000)
signal_data = np.sin(2 * np.pi * 5 * t) + np.random.normal(0, 0.5, 1000)

# Apply moving average filter
window_size = 10
filtered = signal.savgol_filter(signal_data, window_size, 3)
```

### Finding Peaks
```python
# Find peaks in signal
peaks, properties = signal.find_peaks(signal_data, height=0.5)
print(f"Found {len(peaks)} peaks")
```

## 8. Sparse Matrices

### Creating Sparse Matrices
```python
from scipy.sparse import csr_matrix
import numpy as np

# Create sparse matrix (mostly zeros)
dense = np.array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0]])

# Convert to sparse
sparse = csr_matrix(dense)
print(sparse)
# Saves memory for large matrices with many zeros
```

## Key Takeaways
- SciPy extends NumPy with scientific computing tools
- Use `integrate` for calculus operations
- Use `optimize` to find minima, roots, and fit curves
- Use `stats` for statistical analysis
- Use `linalg` for linear algebra operations
- SciPy is essential for scientific and engineering applications

