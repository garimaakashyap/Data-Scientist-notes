# SciPy Intermediate - Step by Step

## 1. Advanced Optimization

### Constrained Optimization
```python
from scipy.optimize import minimize
import numpy as np

# Objective function
def objective(x):
    return x[0]**2 + x[1]**2

# Constraint: x[0] + x[1] = 1
def constraint(x):
    return x[0] + x[1] - 1

# Set up constraints
constraints = {'type': 'eq', 'fun': constraint}

# Bounds: x[0] >= 0, x[1] >= 0
bounds = [(0, None), (0, None)]

# Initial guess
x0 = [0.5, 0.5]

# Minimize with constraints
result = minimize(objective, x0, method='SLSQP', 
                  bounds=bounds, constraints=constraints)
print(f"Optimal: x = {result.x}, f(x) = {result.fun}")
```

### Global Optimization
```python
from scipy.optimize import differential_evolution

# Function with multiple local minima
def objective(x):
    return (x[0] - 2)**2 + (x[1] - 3)**2 + np.sin(x[0]) * np.sin(x[1])

# Bounds for search
bounds = [(-5, 5), (-5, 5)]

# Global optimization
result = differential_evolution(objective, bounds)
print(f"Global minimum: x = {result.x}, f(x) = {result.fun}")
```

### Least Squares Fitting
```python
from scipy.optimize import least_squares
import numpy as np

# Define residual function
def residuals(params, x, y):
    a, b = params
    return y - (a * x + b)

# Data
x_data = np.array([0, 1, 2, 3, 4])
y_data = np.array([1, 3, 5, 7, 9])

# Initial guess
params0 = [1, 1]

# Fit
result = least_squares(residuals, params0, args=(x_data, y_data))
print(f"Fitted parameters: {result.x}")
```

## 2. Advanced Integration

### Integration with Infinite Limits
```python
from scipy import integrate
import numpy as np

# Integrate from -infinity to +infinity
def f(x):
    return np.exp(-x**2)

result, error = integrate.quad(f, -np.inf, np.inf)
print(f"Integral: {result:.6f}")  # sqrt(pi) ≈ 1.772454
```

### Integration with Singularities
```python
# Function with singularity at x=0
def f(x):
    return 1 / np.sqrt(x)

# Integrate from 0 to 1 (singularity at 0)
result, error = integrate.quad(f, 0, 1)
print(f"Integral: {result:.6f}")
```

### Numerical Integration Methods
```python
# Trapezoidal rule
x = np.linspace(0, 2, 100)
y = x**2
result = integrate.trapz(y, x)
print(f"Trapezoidal: {result:.6f}")

# Simpson's rule (more accurate)
result = integrate.simpson(y, x)
print(f"Simpson's: {result:.6f}")
```

## 3. Advanced Interpolation

### 2D Interpolation
```python
from scipy.interpolate import griddata
import numpy as np

# Random scattered data
points = np.random.rand(100, 2)
values = np.sin(points[:, 0] * np.pi) * np.cos(points[:, 1] * np.pi)

# Regular grid
grid_x, grid_y = np.mgrid[0:1:100j, 0:1:100j]

# Interpolate
grid_z = griddata(points, values, (grid_x, grid_y), method='cubic')
```

### Spline Interpolation
```python
from scipy.interpolate import UnivariateSpline
import numpy as np

# Data
x = np.linspace(0, 10, 20)
y = np.sin(x) + np.random.normal(0, 0.1, 20)

# Create spline
spline = UnivariateSpline(x, y, s=0)  # s=0 means no smoothing

# Evaluate at new points
x_new = np.linspace(0, 10, 100)
y_new = spline(x_new)
```

### B-Spline Interpolation
```python
from scipy.interpolate import BSpline, make_interp_spline

# Create B-spline
x = np.array([0, 1, 2, 3, 4, 5])
y = np.array([0, 2, 4, 6, 8, 10])

spline = make_interp_spline(x, y, k=3)  # k=3 is cubic

# Evaluate
x_new = np.linspace(0, 5, 100)
y_new = spline(x_new)
```

## 4. Advanced Statistics

### Probability Distributions
```python
from scipy.stats import norm, t, chi2, f
import numpy as np

# Normal distribution
normal = norm(loc=0, scale=1)
print(f"P(X < 1.96) = {normal.cdf(1.96):.4f}")  # 0.9750

# t-distribution
t_dist = t(df=10)  # 10 degrees of freedom
print(f"t-critical (α=0.05): {t_dist.ppf(0.975):.4f}")

# Chi-square distribution
chi2_dist = chi2(df=5)
print(f"Chi-square critical: {chi2_dist.ppf(0.95):.4f}")

# F-distribution
f_dist = f(dfn=10, dfd=20)
print(f"F-critical: {f_dist.ppf(0.95):.4f}")
```

### Statistical Tests
```python
from scipy.stats import ttest_ind, mannwhitneyu, chi2_contingency

# Two-sample t-test
group1 = np.array([1, 2, 3, 4, 5])
group2 = np.array([6, 7, 8, 9, 10])
statistic, p_value = ttest_ind(group1, group2)
print(f"t-test: statistic={statistic:.4f}, p={p_value:.4f}")

# Mann-Whitney U test (non-parametric)
statistic, p_value = mannwhitneyu(group1, group2)
print(f"Mann-Whitney: statistic={statistic}, p={p_value:.4f}")

# Chi-square test for independence
contingency_table = np.array([[10, 20], [15, 25]])
chi2_stat, p_value, dof, expected = chi2_contingency(contingency_table)
print(f"Chi-square: statistic={chi2_stat:.4f}, p={p_value:.4f}")
```

### Correlation Tests
```python
from scipy.stats import pearsonr, spearmanr

x = np.array([1, 2, 3, 4, 5])
y = np.array([2, 4, 6, 8, 10])

# Pearson correlation
corr, p_value = pearsonr(x, y)
print(f"Pearson r = {corr:.4f}, p = {p_value:.4f}")

# Spearman correlation (rank-based)
corr, p_value = spearmanr(x, y)
print(f"Spearman ρ = {corr:.4f}, p = {p_value:.4f}")
```

## 5. Advanced Linear Algebra

### SVD (Singular Value Decomposition)
```python
from scipy.linalg import svd
import numpy as np

A = np.array([[1, 2], [3, 4], [5, 6]])

# SVD decomposition
U, s, Vt = svd(A)
print("U shape:", U.shape)
print("Singular values:", s)
print("Vt shape:", Vt.shape)

# Reconstruct matrix
A_reconstructed = U @ np.diag(s) @ Vt
print("Reconstruction error:", np.linalg.norm(A - A_reconstructed))
```

### QR Decomposition
```python
from scipy.linalg import qr

A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# QR decomposition
Q, R = qr(A)
print("Q (orthogonal):\n", Q)
print("R (upper triangular):\n", R)

# Verify: A = Q @ R
print("Verification:", np.allclose(A, Q @ R))
```

### Solving Sparse Systems
```python
from scipy.sparse import csr_matrix
from scipy.sparse.linalg import spsolve
import numpy as np

# Create sparse matrix
A = csr_matrix([[3, 0, 1], [0, 2, 0], [1, 0, 3]])
b = np.array([1, 2, 3])

# Solve sparse system
x = spsolve(A, b)
print("Solution:", x)
```

## 6. Advanced Signal Processing

### Fourier Transform
```python
from scipy.fft import fft, fftfreq, ifft
import numpy as np

# Create signal
t = np.linspace(0, 1, 1000)
signal = np.sin(2 * np.pi * 5 * t) + 0.5 * np.sin(2 * np.pi * 10 * t)

# FFT
fft_signal = fft(signal)
frequencies = fftfreq(len(signal), t[1] - t[0])

# Power spectrum
power = np.abs(fft_signal)**2

# Inverse FFT
reconstructed = ifft(fft_signal)
```

### Filter Design
```python
from scipy import signal
import numpy as np

# Design low-pass filter
nyquist = 0.5
cutoff = 0.1
b, a = signal.butter(4, cutoff, btype='low')

# Apply filter
t = np.linspace(0, 1, 1000)
noisy = np.sin(2 * np.pi * 5 * t) + np.random.normal(0, 0.5, 1000)
filtered = signal.filtfilt(b, a, noisy)
```

### Convolution
```python
# Signal
signal_data = np.array([1, 2, 3, 4, 5])

# Kernel
kernel = np.array([0.5, 0.5])  # Moving average

# Convolve
convolved = signal.convolve(signal_data, kernel, mode='same')
print("Convolved:", convolved)
```

## 7. Image Processing

### Basic Image Operations
```python
from scipy import ndimage
import numpy as np

# Create sample image
image = np.random.rand(100, 100)

# Gaussian blur
blurred = ndimage.gaussian_filter(image, sigma=2)

# Edge detection (Sobel)
sobel_x = ndimage.sobel(image, axis=0)
sobel_y = ndimage.sobel(image, axis=1)
edges = np.hypot(sobel_x, sobel_y)

# Rotate image
rotated = ndimage.rotate(image, angle=45)
```

### Morphological Operations
```python
from scipy.ndimage import binary_erosion, binary_dilation, binary_opening

# Binary image
binary_image = np.random.rand(100, 100) > 0.5

# Erosion
eroded = binary_erosion(binary_image)

# Dilation
dilated = binary_dilation(binary_image)

# Opening (erosion followed by dilation)
opened = binary_opening(binary_image)
```

## 8. Spatial Data Structures

### Distance Calculations
```python
from scipy.spatial.distance import euclidean, cityblock, cosine

point1 = np.array([0, 0])
point2 = np.array([3, 4])

# Euclidean distance
dist = euclidean(point1, point2)
print(f"Euclidean: {dist:.2f}")  # 5.0

# Manhattan distance
dist = cityblock(point1, point2)
print(f"Manhattan: {dist}")  # 7

# Cosine distance
dist = cosine(point1, point2)
print(f"Cosine: {dist:.4f}")
```

### KD-Tree for Nearest Neighbors
```python
from scipy.spatial import KDTree
import numpy as np

# Create points
points = np.random.rand(100, 2)

# Build KD-tree
tree = KDTree(points)

# Query nearest neighbor
query_point = np.array([0.5, 0.5])
distance, index = tree.query(query_point)
print(f"Nearest point at index {index}, distance {distance:.4f}")

# Query k nearest neighbors
distances, indices = tree.query(query_point, k=5)
print(f"5 nearest neighbors: {indices}")
```

## 9. Special Functions

### Bessel Functions
```python
from scipy.special import jv, yv, jn_zeros
import numpy as np

# Bessel function of first kind
x = np.linspace(0, 10, 100)
j0 = jv(0, x)  # Order 0
j1 = jv(1, x)  # Order 1

# Bessel function of second kind
y0 = yv(0, x)

# Zeros of Bessel function
zeros = jn_zeros(0, 5)  # First 5 zeros of J0
print("Zeros of J0:", zeros)
```

### Gamma and Related Functions
```python
from scipy.special import gamma, factorial, gammaln

# Gamma function
print(f"Γ(5) = {gamma(5):.2f}")  # 24.00 (equals 4!)

# Factorial
print(f"5! = {factorial(5)}")  # 120

# Log of gamma (for large numbers)
print(f"ln(Γ(100)) = {gammaln(100):.2f}")
```

## Key Takeaways
- Constrained optimization solves real-world problems with limits
- Advanced integration handles difficult cases (infinite limits, singularities)
- Statistical tests help make data-driven decisions
- Signal processing enables analysis of time-series data
- Spatial data structures speed up geometric queries
- Special functions are essential for advanced mathematics

