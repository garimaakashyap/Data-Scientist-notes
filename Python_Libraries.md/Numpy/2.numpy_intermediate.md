# NumPy Intermediate - Step by Step

## 1. Array Indexing and Slicing

### Boolean Indexing
```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Get elements greater than 5
filtered = arr[arr > 5]
print(filtered)  # [6 7 8 9 10]

# Get even numbers
evens = arr[arr % 2 == 0]
print(evens)  # [2 4 6 8 10]
```

### Fancy Indexing
```python
arr = np.array([10, 20, 30, 40, 50])

# Select specific indices
selected = arr[[0, 2, 4]]
print(selected)  # [10 30 50]
```

## 2. Array Manipulation

### Concatenation
```python
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

# Join arrays
combined = np.concatenate([arr1, arr2])
print(combined)  # [1 2 3 4 5 6]

# Stack vertically
stacked = np.vstack([arr1, arr2])
print(stacked)
# [[1 2 3]
#  [4 5 6]]

# Stack horizontally
hstacked = np.hstack([arr1, arr2])
print(hstacked)  # [1 2 3 4 5 6]
```

### Splitting Arrays
```python
arr = np.array([1, 2, 3, 4, 5, 6])

# Split into 3 equal parts
parts = np.split(arr, 3)
print(parts)  # [array([1, 2]), array([3, 4]), array([5, 6])]
```

## 3. Broadcasting

Broadcasting allows operations between arrays of different shapes.

```python
# Array and scalar
arr = np.array([[1, 2, 3], [4, 5, 6]])
result = arr + 10
print(result)
# [[11 12 13]
#  [14 15 16]]

# Different sized arrays
arr1 = np.array([[1], [2], [3]])  # 3x1
arr2 = np.array([10, 20, 30])     # 1x3
result = arr1 + arr2
print(result)
# [[11 21 31]
#  [12 22 32]
#  [13 23 33]]
```

## 4. Mathematical Operations

### Matrix Operations
```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

# Element-wise multiplication
print(a * b)
# [[ 5 12]
#  [21 32]]

# Matrix multiplication (dot product)
print(np.dot(a, b))
# [[19 22]
#  [43 50]]

# Or using @ operator
print(a @ b)
# [[19 22]
#  [43 50]]
```

### Statistical Functions
```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Sum along axis
print(np.sum(arr, axis=0))  # [12 15 18] - sum of columns
print(np.sum(arr, axis=1))  # [6 15 24] - sum of rows

# Mean, median, std
print(np.mean(arr))         # 5.0 - overall mean
print(np.median(arr))       # 5.0 - overall median
print(np.std(arr))          # 2.581... - standard deviation
```

## 5. Array Copying

### Shallow Copy (View)
```python
arr = np.array([1, 2, 3, 4, 5])
view = arr.view()
view[0] = 100
print(arr)   # [100 2 3 4 5] - original changed!
```

### Deep Copy
```python
arr = np.array([1, 2, 3, 4, 5])
copy = arr.copy()
copy[0] = 100
print(arr)   # [1 2 3 4 5] - original unchanged
print(copy)  # [100 2 3 4 5]
```

## 6. Working with NaN and Infinity

```python
# Create arrays with NaN (Not a Number)
arr = np.array([1, 2, np.nan, 4, 5])

# Check for NaN
print(np.isnan(arr))  # [False False True False False]

# Remove NaN values
clean = arr[~np.isnan(arr)]
print(clean)  # [1. 2. 4. 5.]

# Infinity
inf_arr = np.array([1, 2, np.inf, 4])
print(np.isinf(inf_arr))  # [False False True False]
```

## 7. Sorting and Searching

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])

# Sort
sorted_arr = np.sort(arr)
print(sorted_arr)  # [1 1 2 3 4 5 6 9]

# Find indices of sorted array
indices = np.argsort(arr)
print(indices)  # [1 3 6 0 2 4 7 5]

# Find maximum/minimum indices
print(np.argmax(arr))  # 5 - index of max value
print(np.argmin(arr))  # 1 - index of min value
```

## 8. Random Numbers

```python
# Set seed for reproducibility
np.random.seed(42)

# Random integers
random_ints = np.random.randint(1, 10, size=5)
print(random_ints)  # [6 3 7 4 6]

# Random floats between 0 and 1
random_floats = np.random.random(5)
print(random_floats)

# Random choice from array
choices = np.random.choice([1, 2, 3, 4, 5], size=3)
print(choices)  # [4 5 1]

# Normal distribution
normal = np.random.normal(0, 1, size=5)  # mean=0, std=1
print(normal)
```

## 9. Linear Algebra

```python
# Transpose
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print(matrix.T)
# [[1 4]
#  [2 5]
#  [3 6]]

# Determinant
square = np.array([[1, 2], [3, 4]])
det = np.linalg.det(square)
print(det)  # -2.0

# Inverse matrix
inv = np.linalg.inv(square)
print(inv)
# [[-2.   1. ]
#  [ 1.5 -0.5]]
```

## Key Takeaways
- Boolean indexing helps filter arrays easily
- Broadcasting makes operations between different shapes possible
- Always use `.copy()` when you don't want to modify the original
- NumPy has powerful linear algebra functions
