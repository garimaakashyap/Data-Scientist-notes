# NumPy Advanced - Deep Dive

## 1. Structured Arrays

Create arrays with different data types for each column (like a table).

```python
# Define structure
data = np.array([('Alice', 25, 5.6), ('Bob', 30, 5.9), ('Charlie', 35, 6.0)],
                dtype=[('name', 'U10'), ('age', 'i4'), ('height', 'f4')])

print(data['name'])    # ['Alice' 'Bob' 'Charlie']
print(data['age'])     # [25 30 35]
print(data[0])          # ('Alice', 25, 5.6)
```

## 2. Advanced Indexing

### Multi-dimensional Indexing
```python
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

# Select specific rows and columns
rows = [0, 2]
cols = [1, 3]
selected = arr[np.ix_(rows, cols)]
print(selected)
# [[ 2  4]
#  [10 12]]
```

### Conditional Operations
```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Where function (like if-else)
result = np.where(arr > 5, arr * 2, arr)
print(result)  # [1 2 3 4 5 12 14 16 18 20]

# Find indices where condition is true
indices = np.where(arr % 2 == 0)
print(indices)  # (array([1, 3, 5, 7, 9]),)
```

## 3. Advanced Array Operations

### Meshgrid (for plotting)
```python
x = np.linspace(0, 5, 6)
y = np.linspace(0, 5, 6)

X, Y = np.meshgrid(x, y)
print(X)
# [[0. 1. 2. 3. 4. 5.]
#  [0. 1. 2. 3. 4. 5.]
#  ...]

print(Y)
# [[0. 0. 0. 0. 0. 0.]
#  [1. 1. 1. 1. 1. 1.]
#  ...]
```

### Advanced Reshaping
```python
arr = np.arange(24)

# Reshape to 3D
arr_3d = arr.reshape(2, 3, 4)
print(arr_3d.shape)  # (2, 3, 4)

# Flatten specific dimensions
flattened = arr_3d.reshape(-1, 4)  # -1 means "figure it out"
print(flattened.shape)  # (6, 4)
```

## 4. Universal Functions (ufuncs)

### Custom ufuncs
```python
def my_function(x):
    return x ** 2 + 1

# Convert to ufunc
my_ufunc = np.frompyfunc(my_function, 1, 1)

arr = np.array([1, 2, 3, 4])
result = my_ufunc(arr)
print(result)  # [2 5 10 17]
```

### Vectorization
```python
# Instead of loops, use vectorized operations
arr = np.arange(1000000)

# Fast (vectorized)
result1 = arr * 2

# Slow (don't do this)
result2 = np.array([x * 2 for x in arr])
```

## 5. Memory Layout

### Contiguous Arrays
```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

print(arr.flags['C_CONTIGUOUS'])  # True
print(arr.flags['F_CONTIGUOUS'])  # False

# Make Fortran-contiguous
arr_f = np.asfortranarray(arr)
print(arr_f.flags['F_CONTIGUOUS'])  # True
```

## 6. Advanced Linear Algebra

### Eigenvalues and Eigenvectors
```python
matrix = np.array([[1, 2], [2, 1]])

eigenvalues, eigenvectors = np.linalg.eig(matrix)
print("Eigenvalues:", eigenvalues)
print("Eigenvectors:", eigenvectors)
```

### Solving Linear Systems
```python
# Solve: 3x + y = 9, x + 2y = 8
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

solution = np.linalg.solve(A, b)
print(solution)  # [2. 3.] means x=2, y=3
```

### SVD (Singular Value Decomposition)
```python
matrix = np.array([[1, 2], [3, 4], [5, 6]])

U, s, Vt = np.linalg.svd(matrix)
print("U shape:", U.shape)
print("Singular values:", s)
print("Vt shape:", Vt.shape)
```

## 7. Performance Optimization

### Using NumPy's Built-in Functions
```python
arr = np.random.rand(1000000)

# Fast - NumPy function
result1 = np.sum(arr)

# Slow - Python loop
result2 = sum(arr)
```

### Memory Efficient Operations
```python
arr = np.array([1, 2, 3, 4, 5])

# In-place operations (saves memory)
arr += 10  # Modifies arr directly
print(arr)  # [11 12 13 14 15]

# Instead of: arr = arr + 10 (creates new array)
```

## 8. Advanced Broadcasting Rules

```python
# Rule: Arrays are compatible if dimensions match or one is 1

# Example 1: (3, 1) + (1, 3) = (3, 3)
a = np.array([[1], [2], [3]])  # (3, 1)
b = np.array([[10, 20, 30]])   # (1, 3)
result = a + b
print(result.shape)  # (3, 3)

# Example 2: (5, 3) + (3,) = (5, 3)
a = np.ones((5, 3))
b = np.array([1, 2, 3])
result = a + b
print(result.shape)  # (5, 3)
```

## 9. Masked Arrays

Handle missing or invalid data.

```python
import numpy.ma as ma

# Create array with invalid values
data = np.array([1, 2, -999, 4, 5])
masked = ma.masked_where(data == -999, data)

print(masked)  # [1 2 -- 4 5]
print(ma.mean(masked))  # 3.0 (ignores masked values)
```

## 10. File I/O

### Save and Load Arrays
```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Save as binary (.npy)
np.save('my_array.npy', arr)

# Load
loaded = np.load('my_array.npy')

# Save as text
np.savetxt('my_array.txt', arr)

# Load text
loaded_txt = np.loadtxt('my_array.txt')
```

### CSV Files
```python
# Save to CSV
np.savetxt('data.csv', arr, delimiter=',')

# Load from CSV
data = np.loadtxt('data.csv', delimiter=',')
```

## 11. Advanced Statistical Functions

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Percentiles
print(np.percentile(arr, 50))   # 50th percentile (median)
print(np.percentile(arr, [25, 50, 75]))  # Multiple percentiles

# Correlation
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([2, 4, 6, 8, 10])
correlation = np.corrcoef(arr1, arr2)
print(correlation)

# Covariance
covariance = np.cov(arr1, arr2)
print(covariance)
```

## 12. Polynomial Operations

```python
# Create polynomial: x^2 + 2x + 3
coeffs = np.array([1, 2, 3])  # coefficients from highest to lowest

# Evaluate at x=5
value = np.polyval(coeffs, 5)
print(value)  # 38 (25 + 10 + 3)

# Find roots
roots = np.roots(coeffs)
print(roots)  # Roots of x^2 + 2x + 3 = 0
```

## Key Takeaways
- Structured arrays let you work with table-like data
- Vectorization is key for performance
- NumPy has powerful linear algebra capabilities
- Use masked arrays for handling missing data
- Always prefer NumPy functions over Python loops

