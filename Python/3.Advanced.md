# Python Advanced

## Table of Contents
1. [Decorators](#decorators)
2. [Context Managers](#context-managers)
3. [Metaclasses](#metaclasses)
4. [Descriptors](#descriptors)
5. [Property and Descriptor Protocols](#property-and-descriptor-protocols)
6. [Abstract Base Classes](#abstract-base-classes)
7. [Multiple Inheritance and MRO](#multiple-inheritance-and-mro)
8. [Data Classes](#data-classes)
9. [Type Hints and Type Checking](#type-hints-and-type-checking)
10. [Async/Await and Asynchronous Programming](#asyncawait-and-asynchronous-programming)
11. [Concurrency and Parallelism](#concurrency-and-parallelism)
12. [Memory Management](#memory-management)
13. [Metaprogramming](#metaprogramming)
14. [Advanced Functions](#advanced-functions)
15. [Design Patterns in Python](#design-patterns-in-python)

---

## Decorators

### Function Decorators
```python
# Basic decorator
def my_decorator(func):
    def wrapper():
        print("Before function call")
        func()
        print("After function call")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Output:
# Before function call
# Hello!
# After function call
```

### Decorators with Arguments
```python
# Decorator with arguments
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# Output: Hello, Alice! (printed 3 times)
```

### Preserving Function Metadata
```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # Preserves function metadata
    def wrapper(*args, **kwargs):
        """Wrapper function"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def add(a, b):
    """Add two numbers"""
    return a + b

print(add.__name__)  # add (not wrapper)
print(add.__doc__)   # Add two numbers
```

### Class Decorators
```python
# Decorator as a class
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} has been called {self.count} times")
        return self.func(*args, **kwargs)

@CountCalls
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")  # greet has been called 1 times
greet("Bob")    # greet has been called 2 times
```

### Common Decorator Patterns
```python
import time
from functools import wraps, lru_cache

# Timing decorator
def timing(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

# Caching decorator
@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Validation decorator
def validate_types(**types):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Validate arguments
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Retry decorator
def retry(max_attempts=3):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"Attempt {attempt + 1} failed: {e}")
            return None
        return wrapper
    return decorator
```

### Property Decorators
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        return self._radius
    
    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius must be non-negative")
        self._radius = value
    
    @radius.deleter
    def radius(self):
        del self._radius
    
    @property
    def area(self):
        return 3.14159 * self._radius ** 2
```

### Class Method and Static Method Decorators
```python
class MyClass:
    class_var = 0
    
    @classmethod
    def class_method(cls):
        return cls.class_var
    
    @staticmethod
    def static_method():
        return "Static method"
```

---

## Context Managers

### Using Context Managers
```python
# With statement
with open("file.txt", "r") as f:
    content = f.read()
# File automatically closed

# Multiple context managers
with open("input.txt", "r") as infile, open("output.txt", "w") as outfile:
    data = infile.read()
    outfile.write(data)
```

### Creating Context Managers
```python
# Class-based context manager
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        # Return False to propagate exception, True to suppress
        return False

# Usage
with FileManager("file.txt", "r") as f:
    content = f.read()
```

### Context Manager with contextlib
```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()

# Usage
with file_manager("file.txt", "r") as f:
    content = f.read()
```

### Advanced Context Managers
```python
from contextlib import contextmanager, redirect_stdout, suppress
import os

# Redirect stdout
@contextmanager
def suppress_stdout():
    with open(os.devnull, "w") as devnull:
        with redirect_stdout(devnull):
            yield

# Suppress exceptions
with suppress(FileNotFoundError):
    os.remove("nonexistent.txt")

# Timer context manager
from contextlib import contextmanager
import time

@contextmanager
def timer():
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(f"Elapsed time: {end - start:.4f} seconds")

# Usage
with timer():
    # Some code
    time.sleep(1)
```

---

## Metaclasses

### Understanding Metaclasses
```python
# Everything is an object, including classes
# Classes are instances of metaclasses (usually 'type')

# Creating class with type
MyClass = type('MyClass', (object,), {'x': 10})

# Equivalent to:
class MyClass:
    x = 10
```

### Custom Metaclass
```python
class Meta(type):
    def __new__(cls, name, bases, namespace):
        # Modify namespace before class creation
        namespace['created_by'] = 'Meta'
        return super().__new__(cls, name, bases, namespace)
    
    def __init__(cls, name, bases, namespace):
        super().__init__(name, bases, namespace)
        cls.initialized = True

class MyClass(metaclass=Meta):
    pass

print(MyClass.created_by)  # Meta
print(MyClass.initialized)  # True
```

### Metaclass Use Cases
```python
# Singleton pattern with metaclass
class Singleton(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=Singleton):
    def __init__(self):
        print("Database connection created")

db1 = Database()  # Database connection created
db2 = Database()  # (no output, returns same instance)
print(db1 is db2)  # True

# Registering classes
class PluginRegistry(type):
    plugins = []
    
    def __new__(cls, name, bases, namespace):
        new_class = super().__new__(cls, name, bases, namespace)
        if name != 'Plugin':
            cls.plugins.append(new_class)
        return new_class

class Plugin(metaclass=PluginRegistry):
    pass

class Plugin1(Plugin):
    pass

class Plugin2(Plugin):
    pass

print(PluginRegistry.plugins)  # [<class '__main__.Plugin1'>, <class '__main__.Plugin2'>]
```

---

## Descriptors

### Descriptor Protocol
```python
# Descriptor class
class Descriptor:
    def __get__(self, obj, objtype=None):
        return f"Getting {self.name}"
    
    def __set__(self, obj, value):
        if value < 0:
            raise ValueError("Value must be non-negative")
        obj.__dict__[self.name] = value
    
    def __delete__(self, obj):
        del obj.__dict__[self.name]
    
    def __set_name__(self, owner, name):
        self.name = name

class MyClass:
    x = Descriptor()

obj = MyClass()
obj.x = 10
print(obj.x)  # Getting x
```

### Property as Descriptor
```python
# Property is implemented as a descriptor
class Property:
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)
    
    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)
    
    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)
    
    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)
    
    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
```

---

## Property and Descriptor Protocols

### Advanced Property Usage
```python
class Temperature:
    def __init__(self):
        self._celsius = 0
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        self._celsius = value
    
    @property
    def fahrenheit(self):
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self._celsius = (value - 32) * 5/9

temp = Temperature()
temp.celsius = 25
print(temp.fahrenheit)  # 77.0
temp.fahrenheit = 100
print(temp.celsius)  # 37.777...
```

---

## Abstract Base Classes

### Using ABC Module
```python
from abc import ABC, abstractmethod, abstractproperty

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass
    
    @abstractproperty
    def name(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    @property
    def name(self):
        return "Rectangle"
```

### Registering Virtual Subclasses
```python
from abc import ABC

class MyABC(ABC):
    pass

# Register as virtual subclass
MyABC.register(list)

print(issubclass(list, MyABC))  # True
print(isinstance([], MyABC))    # True
```

---

## Multiple Inheritance and MRO

### Method Resolution Order (MRO)
```python
class A:
    def method(self):
        return "A"

class B(A):
    def method(self):
        return "B"

class C(A):
    def method(self):
        return "C"

class D(B, C):
    pass

# MRO: D -> B -> C -> A -> object
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, 
#  <class '__main__.A'>, <class 'object'>)

d = D()
print(d.method())  # B (first in MRO)
```

### super() Function
```python
class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")
        super().method()  # Call parent method

class C(A):
    def method(self):
        print("C")
        super().method()

class D(B, C):
    def method(self):
        print("D")
        super().method()

d = D()
d.method()
# Output:
# D
# B
# C
# A
```

---

## Data Classes

### Basic Data Classes
```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Point:
    x: float
    y: float
    z: float = 0.0  # Default value
    
    def distance(self):
        return (self.x**2 + self.y**2 + self.z**2)**0.5

@dataclass
class Person:
    name: str
    age: int
    email: str = ""
    hobbies: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        if self.age < 0:
            raise ValueError("Age cannot be negative")

p1 = Point(1, 2, 3)
p2 = Point(1, 2, 3)
print(p1 == p2)  # True (automatic __eq__)
```

### Advanced Data Classes
```python
from dataclasses import dataclass, field, asdict, astuple
from typing import ClassVar

@dataclass
class Employee:
    # Class variable
    company: ClassVar[str] = "ACME Corp"
    
    # Instance variables
    name: str
    age: int
    salary: float = 0.0
    
    # Private field (not in __repr__)
    _id: int = field(repr=False)
    
    # Exclude from comparison
    temp_data: dict = field(compare=False, default_factory=dict)
    
    def __post_init__(self):
        if self.salary < 0:
            raise ValueError("Salary cannot be negative")

emp = Employee("Alice", 30, 50000, 123)
print(asdict(emp))  # Convert to dictionary
print(astuple(emp))  # Convert to tuple
```

---

## Type Hints and Type Checking

### Basic Type Hints
```python
from typing import List, Dict, Tuple, Optional, Union, Any, Callable

def add(a: int, b: int) -> int:
    return a + b

def process_data(data: List[int]) -> Dict[str, int]:
    return {"sum": sum(data), "count": len(data)}

def get_value(key: str) -> Optional[str]:
    # Returns str or None
    pass

def process(value: Union[int, str]) -> None:
    # Accepts int or str
    pass

def callback(func: Callable[[int, int], int]) -> int:
    return func(1, 2)
```

### Advanced Type Hints
```python
from typing import Generic, TypeVar, Protocol, TypedDict

T = TypeVar('T')

class Stack(Generic[T]):
    def __init__(self):
        self.items: List[T] = []
    
    def push(self, item: T) -> None:
        self.items.append(item)
    
    def pop(self) -> T:
        return self.items.pop()

# Protocol (structural subtyping)
class Drawable(Protocol):
    def draw(self) -> None: ...

def render(obj: Drawable) -> None:
    obj.draw()

# TypedDict
class PersonDict(TypedDict):
    name: str
    age: int
    email: Optional[str]
```

### Type Checking with mypy
```python
# Install: pip install mypy
# Run: mypy script.py

from typing import List

def process_numbers(numbers: List[int]) -> int:
    return sum(numbers)

# Type checking will catch errors
process_numbers([1, 2, 3])  # OK
process_numbers(["a", "b"])  # Error: List[str] not compatible with List[int]
```

---

## Async/Await and Asynchronous Programming

### Basic Async/Await
```python
import asyncio

async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(1)  # Simulate I/O operation
    return "Data"

async def main():
    result = await fetch_data()
    print(result)

# Run async function
asyncio.run(main())
```

### Concurrent Execution
```python
import asyncio

async def task(name, delay):
    print(f"Task {name} started")
    await asyncio.sleep(delay)
    print(f"Task {name} completed")
    return f"Result from {name}"

async def main():
    # Run tasks concurrently
    results = await asyncio.gather(
        task("A", 2),
        task("B", 1),
        task("C", 3)
    )
    print(results)

asyncio.run(main())
```

### Async Context Managers
```python
import asyncio

class AsyncFileManager:
    async def __aenter__(self):
        print("Opening file...")
        await asyncio.sleep(0.1)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Closing file...")
        await asyncio.sleep(0.1)
    
    async def read(self):
        await asyncio.sleep(0.5)
        return "File content"

async def main():
    async with AsyncFileManager() as file:
        content = await file.read()
        print(content)

asyncio.run(main())
```

### Async Iterators
```python
import asyncio

class AsyncRange:
    def __init__(self, start, stop):
        self.start = start
        self.stop = stop
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.start >= self.stop:
            raise StopAsyncIteration
        await asyncio.sleep(0.1)
        self.start += 1
        return self.start - 1

async def main():
    async for num in AsyncRange(0, 5):
        print(num)

asyncio.run(main())
```

---

## Concurrency and Parallelism

### Threading
```python
import threading
import time

def worker(name, delay):
    print(f"Worker {name} started")
    time.sleep(delay)
    print(f"Worker {name} finished")

# Create threads
thread1 = threading.Thread(target=worker, args=("A", 2))
thread2 = threading.Thread(target=worker, args=("B", 1))

# Start threads
thread1.start()
thread2.start()

# Wait for threads to complete
thread1.join()
thread2.join()

print("All threads completed")
```

### Threading with Locks
```python
import threading

counter = 0
lock = threading.Lock()

def increment():
    global counter
    for _ in range(100000):
        with lock:
            counter += 1

threads = []
for _ in range(10):
    thread = threading.Thread(target=increment)
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print(f"Counter: {counter}")  # 1000000
```

### Multiprocessing
```python
import multiprocessing
import time

def worker(name, delay):
    print(f"Worker {name} started (PID: {multiprocessing.current_process().pid})")
    time.sleep(delay)
    print(f"Worker {name} finished")
    return f"Result from {name}"

if __name__ == "__main__":
    # Create processes
    process1 = multiprocessing.Process(target=worker, args=("A", 2))
    process2 = multiprocessing.Process(target=worker, args=("B", 1))
    
    # Start processes
    process1.start()
    process2.start()
    
    # Wait for processes to complete
    process1.join()
    process2.join()
    
    print("All processes completed")
```

### Process Pool
```python
from multiprocessing import Pool
import time

def square(x):
    return x * x

if __name__ == "__main__":
    with Pool(processes=4) as pool:
        numbers = range(10)
        results = pool.map(square, numbers)
        print(results)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

---

## Memory Management

### Garbage Collection
```python
import gc

# Manual garbage collection
gc.collect()

# Get garbage collection statistics
print(gc.get_stats())

# Enable/disable garbage collection
gc.disable()
gc.enable()

# Get reference counts
import sys
x = [1, 2, 3]
print(sys.getrefcount(x))  # Reference count
```

### Weak References
```python
import weakref

class MyClass:
    def __init__(self, name):
        self.name = name
    
    def __repr__(self):
        return f"MyClass({self.name})"

obj = MyClass("test")
weak_ref = weakref.ref(obj)

print(weak_ref())  # MyClass(test)
del obj
print(weak_ref())  # None (object was garbage collected)
```

### Memory Profiling
```python
# Install: pip install memory-profiler

from memory_profiler import profile

@profile
def my_function():
    large_list = [i for i in range(1000000)]
    return sum(large_list)

my_function()
```

---

## Metaprogramming

### Dynamic Attribute Access
```python
class DynamicClass:
    def __getattr__(self, name):
        return f"Attribute {name} not found, but handled"
    
    def __setattr__(self, name, value):
        super().__setattr__(name, value)
    
    def __delattr__(self, name):
        super().__delattr__(name)

obj = DynamicClass()
print(obj.nonexistent)  # Attribute nonexistent not found, but handled
```

### Dynamic Class Creation
```python
def create_class(class_name, base_classes, attributes):
    return type(class_name, base_classes, attributes)

MyClass = create_class(
    "MyClass",
    (object,),
    {"x": 10, "y": 20, "method": lambda self: self.x + self.y}
)

obj = MyClass()
print(obj.method())  # 30
```

### Monkey Patching
```python
class MyClass:
    def method(self):
        return "Original"

obj = MyClass()
print(obj.method())  # Original

# Monkey patch
def new_method(self):
    return "Patched"

MyClass.method = new_method
print(obj.method())  # Patched
```

---

## Advanced Functions

### Function Introspection
```python
def my_function(a, b, c=10, *args, **kwargs):
    """Documentation string"""
    return a + b + c

# Function attributes
print(my_function.__name__)      # my_function
print(my_function.__doc__)       # Documentation string
print(my_function.__defaults__)  # (10,)
print(my_function.__code__.co_varnames)  # ('a', 'b', 'c', 'args', 'kwargs')
```

### Partial Functions
```python
from functools import partial

def multiply(x, y):
    return x * y

# Create partial function
double = partial(multiply, 2)
print(double(5))  # 10

triple = partial(multiply, 3)
print(triple(5))  # 15
```

### Function Caching
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# First call computes value
print(fibonacci(100))  # Computes

# Subsequent calls use cache
print(fibonacci(100))  # From cache
```

---

## Design Patterns in Python

### Singleton Pattern
```python
class Singleton:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True
```

### Factory Pattern
```python
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

def animal_factory(animal_type):
    animals = {
        "dog": Dog,
        "cat": Cat
    }
    return animals.get(animal_type, lambda: None)()

dog = animal_factory("dog")
cat = animal_factory("cat")
print(dog.speak())  # Woof!
print(cat.speak())  # Meow!
```

### Observer Pattern
```python
class Observer:
    def update(self, subject):
        pass

class Subject:
    def __init__(self):
        self._observers = []
    
    def attach(self, observer):
        self._observers.append(observer)
    
    def notify(self):
        for observer in self._observers:
            observer.update(self)

class ConcreteObserver(Observer):
    def update(self, subject):
        print("Observer notified")

subject = Subject()
observer = ConcreteObserver()
subject.attach(observer)
subject.notify()  # Observer notified
```

### Strategy Pattern
```python
class Strategy:
    def execute(self, data):
        pass

class AddStrategy(Strategy):
    def execute(self, data):
        return sum(data)

class MultiplyStrategy(Strategy):
    def execute(self, data):
        result = 1
        for x in data:
            result *= x
        return result

class Context:
    def __init__(self, strategy):
        self.strategy = strategy
    
    def execute_strategy(self, data):
        return self.strategy.execute(data)

context = Context(AddStrategy())
print(context.execute_strategy([1, 2, 3, 4]))  # 10

context.strategy = MultiplyStrategy()
print(context.execute_strategy([1, 2, 3, 4]))  # 24
```

---

## Practice Exercises

1. Create a decorator that measures execution time and logs it
2. Implement a context manager for database connections
3. Create a metaclass that automatically registers all subclasses
4. Implement a descriptor that validates email addresses
5. Create an async function that fetches data from multiple URLs concurrently
6. Implement a thread-safe counter using locks
7. Create a data class with custom validation
8. Implement the Observer pattern for an event system
9. Create a decorator that caches function results with expiration
10. Implement a custom metaclass for singleton pattern

