# SQL CTEs (Common Table Expressions) - Complete Guide

## What are CTEs?
CTEs (Common Table Expressions) are temporary named result sets that exist only for the duration of a single query. Think of them as "temporary views" that make complex queries easier to read and write.

## Basic Syntax

```sql
WITH cte_name AS (
    -- Your query here
    SELECT ...
)
SELECT * FROM cte_name;
```

## Why Use CTEs?

1. **Readability**: Break complex queries into smaller, understandable parts
2. **Reusability**: Use the same CTE multiple times in one query
3. **Recursion**: Enable recursive queries (hierarchical data)
4. **Debugging**: Test parts of complex queries independently

## 1. Simple CTE Example

```sql
-- Find employees with above-average salary
WITH avg_salary AS (
    SELECT AVG(salary) AS avg_sal
    FROM employees
)
SELECT 
    e.emp_name,
    e.salary,
    a.avg_sal
FROM employees e
CROSS JOIN avg_salary a
WHERE e.salary > a.avg_sal;

-- Without CTE (more complex):
SELECT 
    e.emp_name,
    e.salary,
    (SELECT AVG(salary) FROM employees) AS avg_sal
FROM employees e
WHERE e.salary > (SELECT AVG(salary) FROM employees);
```

## 2. Multiple CTEs

You can define multiple CTEs separated by commas:

```sql
WITH 
    high_earners AS (
        SELECT emp_id, emp_name, salary
        FROM employees
        WHERE salary > 60000
    ),
    it_employees AS (
        SELECT emp_id, emp_name
        FROM employees
        WHERE department_id = 10
    )
SELECT 
    h.emp_name,
    h.salary
FROM high_earners h
INNER JOIN it_employees i 
    ON h.emp_id = i.emp_id;
```

## 3. CTE with Joins

```sql
-- Employees with their department names
WITH emp_dept AS (
    SELECT 
        e.emp_name,
        e.salary,
        d.dept_name
    FROM employees e
    INNER JOIN departments d 
        ON e.department_id = d.dept_id
)
SELECT 
    emp_name,
    dept_name,
    salary
FROM emp_dept
WHERE salary > 55000
ORDER BY salary DESC;
```

## 4. CTE for Aggregations

```sql
-- Department statistics
WITH dept_stats AS (
    SELECT 
        d.dept_name,
        COUNT(e.emp_id) AS emp_count,
        AVG(e.salary) AS avg_salary,
        MAX(e.salary) AS max_salary,
        MIN(e.salary) AS min_salary
    FROM departments d
    LEFT JOIN employees e 
        ON d.dept_id = e.department_id
    GROUP BY d.dept_name
)
SELECT 
    dept_name,
    emp_count,
    ROUND(avg_salary, 2) AS avg_salary,
    max_salary,
    min_salary
FROM dept_stats
WHERE emp_count > 0
ORDER BY avg_salary DESC;
```

## 5. CTE for Data Transformation

```sql
-- Clean and transform data
WITH cleaned_data AS (
    SELECT 
        emp_id,
        UPPER(TRIM(emp_name)) AS emp_name,
        COALESCE(department_id, 0) AS department_id,
        salary
    FROM employees
    WHERE salary IS NOT NULL
),
enriched_data AS (
    SELECT 
        c.emp_name,
        c.salary,
        d.dept_name,
        CASE 
            WHEN c.salary > 60000 THEN 'High'
            WHEN c.salary > 50000 THEN 'Medium'
            ELSE 'Low'
        END AS salary_category
    FROM cleaned_data c
    LEFT JOIN departments d 
        ON c.department_id = d.dept_id
)
SELECT * FROM enriched_data
ORDER BY salary DESC;
```

## 6. Recursive CTEs (Advanced)

Recursive CTEs are powerful for hierarchical data like org charts, categories, or tree structures.

### Basic Recursive CTE Structure

```sql
WITH RECURSIVE cte_name AS (
    -- Anchor member (base case)
    SELECT ... WHERE condition
    
    UNION ALL
    
    -- Recursive member
    SELECT ... FROM cte_name WHERE condition
)
SELECT * FROM cte_name;
```

### Example 1: Employee Hierarchy

```sql
-- Employees with Manager Hierarchy
CREATE TABLE employees_hierarchy (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    manager_id INT,
    salary DECIMAL(10,2)
);

INSERT INTO employees_hierarchy VALUES
(1, 'Alice', NULL, 100000),    -- CEO
(2, 'Bob', 1, 80000),          -- Reports to Alice
(3, 'Charlie', 1, 75000),      -- Reports to Alice
(4, 'Diana', 2, 60000),        -- Reports to Bob
(5, 'Eve', 2, 55000),          -- Reports to Bob
(6, 'Frank', 4, 50000);        -- Reports to Diana

-- Find all subordinates of a manager (including indirect)
WITH RECURSIVE subordinates AS (
    -- Anchor: Start with manager
    SELECT emp_id, emp_name, manager_id, 0 AS level
    FROM employees_hierarchy
    WHERE emp_id = 2  -- Bob's ID
    
    UNION ALL
    
    -- Recursive: Find direct reports
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        s.level + 1
    FROM employees_hierarchy e
    INNER JOIN subordinates s 
        ON e.manager_id = s.emp_id
)
SELECT 
    emp_name,
    level,
    CASE 
        WHEN level = 0 THEN 'Manager'
        WHEN level = 1 THEN 'Direct Report'
        ELSE 'Indirect Report'
    END AS relationship
FROM subordinates
ORDER BY level, emp_name;

-- Result:
-- Bob     | 0 | Manager
-- Diana   | 1 | Direct Report
-- Eve     | 1 | Direct Report
-- Frank   | 2 | Indirect Report
```

### Example 2: Number Sequence

```sql
-- Generate numbers from 1 to 10
WITH RECURSIVE numbers AS (
    -- Anchor: Start with 1
    SELECT 1 AS n
    
    UNION ALL
    
    -- Recursive: Add 1 until 10
    SELECT n + 1
    FROM numbers
    WHERE n < 10
)
SELECT n FROM numbers;

-- Result: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
```

### Example 3: Category Hierarchy

```sql
CREATE TABLE categories (
    category_id INT PRIMARY KEY,
    category_name VARCHAR(50),
    parent_id INT
);

INSERT INTO categories VALUES
(1, 'Electronics', NULL),
(2, 'Computers', 1),
(3, 'Laptops', 2),
(4, 'Phones', 1),
(5, 'Smartphones', 4);

-- Get full category path
WITH RECURSIVE category_path AS (
    -- Anchor: Start with leaf category
    SELECT 
        category_id,
        category_name,
        parent_id,
        CAST(category_name AS VARCHAR(200)) AS full_path
    FROM categories
    WHERE category_id = 5  -- Smartphones
    
    UNION ALL
    
    -- Recursive: Go up the hierarchy
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        CAST(c.category_name || ' > ' || cp.full_path AS VARCHAR(200))
    FROM categories c
    INNER JOIN category_path cp 
        ON c.category_id = cp.parent_id
)
SELECT full_path FROM category_path
WHERE parent_id IS NULL;

-- Result: Electronics > Phones > Smartphones
```

## 7. CTE vs Subquery

### Using Subquery (More Complex)
```sql
SELECT 
    e.emp_name,
    e.salary,
    (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees e
WHERE e.salary > (
    SELECT AVG(salary) FROM employees
)
AND e.department_id IN (
    SELECT dept_id FROM departments WHERE location = 'New York'
);
```

### Using CTE (Cleaner)
```sql
WITH 
    avg_salary AS (
        SELECT AVG(salary) AS avg_sal FROM employees
    ),
    ny_departments AS (
        SELECT dept_id FROM departments WHERE location = 'New York'
    )
SELECT 
    e.emp_name,
    e.salary,
    a.avg_sal AS avg_salary
FROM employees e
CROSS JOIN avg_salary a
WHERE e.salary > a.avg_sal
AND e.department_id IN (SELECT dept_id FROM ny_departments);
```

## 8. CTE for Window Functions

```sql
-- Rank employees within departments
WITH ranked_employees AS (
    SELECT 
        e.emp_name,
        d.dept_name,
        e.salary,
        ROW_NUMBER() OVER (
            PARTITION BY d.dept_name 
            ORDER BY e.salary DESC
        ) AS salary_rank
    FROM employees e
    INNER JOIN departments d 
        ON e.department_id = d.dept_id
)
SELECT 
    emp_name,
    dept_name,
    salary,
    salary_rank
FROM ranked_employees
WHERE salary_rank <= 2;  -- Top 2 in each department
```

## 9. CTE for Data Validation

```sql
-- Find data quality issues
WITH validation_checks AS (
    SELECT 
        emp_id,
        emp_name,
        CASE 
            WHEN emp_name IS NULL THEN 'Missing Name'
            WHEN salary IS NULL THEN 'Missing Salary'
            WHEN salary < 0 THEN 'Negative Salary'
            WHEN department_id IS NULL THEN 'No Department'
            ELSE 'OK'
        END AS validation_status
    FROM employees
)
SELECT 
    validation_status,
    COUNT(*) AS count
FROM validation_checks
GROUP BY validation_status
ORDER BY count DESC;
```

## 10. CTE for Complex Business Logic

```sql
-- Calculate employee bonuses based on multiple criteria
WITH 
    performance_scores AS (
        SELECT 
            emp_id,
            emp_name,
            salary,
            department_id,
            -- Simulated performance score
            RANDOM() * 100 AS performance_score
        FROM employees
    ),
    bonus_calculations AS (
        SELECT 
            ps.emp_id,
            ps.emp_name,
            ps.salary,
            ps.performance_score,
            d.dept_name,
            CASE 
                WHEN ps.performance_score >= 90 THEN ps.salary * 0.20
                WHEN ps.performance_score >= 75 THEN ps.salary * 0.15
                WHEN ps.performance_score >= 60 THEN ps.salary * 0.10
                ELSE ps.salary * 0.05
            END AS bonus_amount
        FROM performance_scores ps
        LEFT JOIN departments d 
            ON ps.department_id = d.dept_id
    )
SELECT 
    emp_name,
    dept_name,
    salary,
    ROUND(performance_score, 2) AS performance_score,
    ROUND(bonus_amount, 2) AS bonus_amount,
    ROUND(salary + bonus_amount, 2) AS total_compensation
FROM bonus_calculations
ORDER BY bonus_amount DESC;
```

## 11. CTE Limitations and Best Practices

### Limitations:
1. CTEs only exist for the duration of the query
2. Can't reference a CTE from a different query
3. Some databases have recursion depth limits

### Best Practices:

1. **Use meaningful names**
```sql
-- Bad
WITH t1 AS (SELECT ...), t2 AS (SELECT ...)

-- Good
WITH high_earners AS (SELECT ...), department_stats AS (SELECT ...)
```

2. **Keep CTEs focused**
```sql
-- Each CTE should do one thing
WITH cleaned_data AS (...),
     aggregated_data AS (...),
     final_results AS (...)
```

3. **Test CTEs independently**
```sql
-- Test this first
WITH test_cte AS (
    SELECT * FROM employees WHERE salary > 50000
)
SELECT * FROM test_cte;

-- Then use in larger query
```

4. **Use CTEs for complex logic, not simple queries**
```sql
-- Don't overuse CTEs for simple queries
-- Simple is fine:
SELECT emp_name FROM employees WHERE salary > 50000;

-- Complex benefits from CTE:
WITH multiple_joins AS (...), aggregations AS (...), filters AS (...)
```

## 12. Real-World Example: Sales Analysis

```sql
-- Sales Analysis with Multiple CTEs
CREATE TABLE sales (
    sale_id INT,
    product_id INT,
    sale_date DATE,
    quantity INT,
    unit_price DECIMAL(10,2),
    customer_id INT
);

WITH 
    -- Calculate total sales per product
    product_sales AS (
        SELECT 
            product_id,
            SUM(quantity * unit_price) AS total_revenue,
            SUM(quantity) AS total_quantity
        FROM sales
        GROUP BY product_id
    ),
    
    -- Calculate monthly sales
    monthly_sales AS (
        SELECT 
            DATE_TRUNC('month', sale_date) AS month,
            SUM(quantity * unit_price) AS monthly_revenue
        FROM sales
        GROUP BY DATE_TRUNC('month', sale_date)
    ),
    
    -- Find top products
    top_products AS (
        SELECT 
            product_id,
            total_revenue,
            ROW_NUMBER() OVER (ORDER BY total_revenue DESC) AS rank
        FROM product_sales
    ),
    
    -- Calculate growth
    sales_growth AS (
        SELECT 
            month,
            monthly_revenue,
            LAG(monthly_revenue) OVER (ORDER BY month) AS prev_month_revenue,
            monthly_revenue - LAG(monthly_revenue) OVER (ORDER BY month) AS growth
        FROM monthly_sales
    )
    
-- Final report
SELECT 
    'Top Products' AS report_section,
    CAST(product_id AS VARCHAR) AS metric,
    CAST(total_revenue AS VARCHAR) AS value
FROM top_products
WHERE rank <= 5

UNION ALL

SELECT 
    'Sales Growth' AS report_section,
    TO_CHAR(month, 'YYYY-MM') AS metric,
    CAST(ROUND(growth, 2) AS VARCHAR) AS value
FROM sales_growth
WHERE growth IS NOT NULL;
```

## Key Takeaways

1. **CTEs make complex queries readable** - Break them into logical parts
2. **CTEs are temporary** - Only exist for one query execution
3. **Multiple CTEs** - Chain them together for complex logic
4. **Recursive CTEs** - Powerful for hierarchical data
5. **Use meaningful names** - Makes code self-documenting
6. **Test CTEs independently** - Debug step by step
7. **CTEs vs Subqueries** - CTEs are often cleaner for complex logic
8. **Performance** - Modern databases optimize CTEs well
9. **Recursion depth** - Be aware of limits in recursive CTEs
10. **Readability first** - Use CTEs when they improve understanding

## Common Patterns

- **Data cleaning** → **Transformation** → **Aggregation** → **Final selection**
- **Base data** → **Filtered data** → **Enriched data** → **Results**
- **Hierarchical data** → **Recursive expansion** → **Final hierarchy**

