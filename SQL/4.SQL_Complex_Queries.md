# SQL Complex Queries - Complete Guide

## What are Complex Queries?
Complex queries combine multiple SQL concepts (joins, subqueries, CTEs, window functions, aggregations) to solve real-world data problems. They require careful planning and understanding of SQL fundamentals.

## Sample Database Schema

```sql
-- Employees
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    department_id INT,
    manager_id INT,
    salary DECIMAL(10,2),
    hire_date DATE
);

-- Departments
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50),
    location VARCHAR(50)
);

-- Projects
CREATE TABLE projects (
    project_id INT PRIMARY KEY,
    project_name VARCHAR(50),
    start_date DATE,
    end_date DATE,
    budget DECIMAL(12,2)
);

-- Employee Projects (Many-to-Many)
CREATE TABLE employee_projects (
    emp_id INT,
    project_id INT,
    role VARCHAR(50),
    hours_worked INT,
    PRIMARY KEY (emp_id, project_id)
);

-- Sales
CREATE TABLE sales (
    sale_id INT PRIMARY KEY,
    emp_id INT,
    sale_date DATE,
    amount DECIMAL(10,2),
    region VARCHAR(50)
);
```

## 1. Multi-Level Aggregations

### Problem: Department statistics with employee details

```sql
-- Get department stats while keeping employee details
SELECT 
    e.emp_name,
    e.salary,
    d.dept_name,
    COUNT(*) OVER (PARTITION BY d.dept_id) AS dept_employee_count,
    AVG(e.salary) OVER (PARTITION BY d.dept_id) AS dept_avg_salary,
    MAX(e.salary) OVER (PARTITION BY d.dept_id) AS dept_max_salary,
    e.salary - AVG(e.salary) OVER (PARTITION BY d.dept_id) AS diff_from_avg
FROM employees e
INNER JOIN departments d ON e.department_id = d.dept_id
ORDER BY d.dept_name, e.salary DESC;
```

### Problem: Hierarchical aggregations

```sql
-- Total sales by employee, department, and overall
SELECT 
    e.emp_name,
    d.dept_name,
    s.amount,
    SUM(s.amount) OVER (PARTITION BY e.emp_id) AS employee_total,
    SUM(s.amount) OVER (PARTITION BY d.dept_id) AS dept_total,
    SUM(s.amount) OVER () AS company_total,
    ROUND(
        100.0 * s.amount / SUM(s.amount) OVER (PARTITION BY d.dept_id),
        2
    ) AS pct_of_dept
FROM sales s
INNER JOIN employees e ON s.emp_id = e.emp_id
INNER JOIN departments d ON e.department_id = d.dept_id;
```

## 2. Correlated Subqueries

### Problem: Employees earning more than their department average

```sql
-- Using correlated subquery
SELECT 
    e1.emp_name,
    e1.salary,
    e1.department_id,
    (SELECT AVG(e2.salary) 
     FROM employees e2 
     WHERE e2.department_id = e1.department_id) AS dept_avg_salary
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary) 
    FROM employees e2 
    WHERE e2.department_id = e1.department_id
);
```

### Problem: Employees with above-average performance in their department

```sql
-- Using EXISTS with correlated subquery
SELECT 
    e.emp_name,
    e.salary,
    d.dept_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.dept_id
WHERE EXISTS (
    SELECT 1
    FROM employees e2
    WHERE e2.department_id = e.department_id
    GROUP BY e2.department_id
    HAVING e.salary > AVG(e2.salary)
);
```

## 3. Multiple CTEs for Complex Logic

### Problem: Employee performance analysis with multiple metrics

```sql
WITH 
    -- Base employee data with department
    emp_dept AS (
        SELECT 
            e.emp_id,
            e.emp_name,
            e.salary,
            e.hire_date,
            d.dept_name,
            d.location
        FROM employees e
        INNER JOIN departments d ON e.department_id = d.dept_id
    ),
    
    -- Sales performance
    sales_performance AS (
        SELECT 
            emp_id,
            COUNT(*) AS total_sales,
            SUM(amount) AS total_revenue,
            AVG(amount) AS avg_sale_amount,
            MAX(amount) AS max_sale
        FROM sales
        GROUP BY emp_id
    ),
    
    -- Project involvement
    project_involvement AS (
        SELECT 
            ep.emp_id,
            COUNT(DISTINCT ep.project_id) AS project_count,
            SUM(ep.hours_worked) AS total_hours
        FROM employee_projects ep
        GROUP BY ep.emp_id
    ),
    
    -- Combined metrics
    combined_metrics AS (
        SELECT 
            ed.emp_id,
            ed.emp_name,
            ed.dept_name,
            ed.salary,
            COALESCE(sp.total_revenue, 0) AS total_revenue,
            COALESCE(sp.total_sales, 0) AS total_sales,
            COALESCE(pi.project_count, 0) AS project_count,
            COALESCE(pi.total_hours, 0) AS total_hours,
            -- Calculate performance score
            CASE 
                WHEN COALESCE(sp.total_revenue, 0) > 100000 
                     AND COALESCE(pi.project_count, 0) >= 2 
                THEN 'High Performer'
                WHEN COALESCE(sp.total_revenue, 0) > 50000 
                     OR COALESCE(pi.project_count, 0) >= 1 
                THEN 'Medium Performer'
                ELSE 'Low Performer'
            END AS performance_category
        FROM emp_dept ed
        LEFT JOIN sales_performance sp ON ed.emp_id = sp.emp_id
        LEFT JOIN project_involvement pi ON ed.emp_id = pi.emp_id
    ),
    
    -- Department rankings
    dept_rankings AS (
        SELECT 
            *,
            ROW_NUMBER() OVER (
                PARTITION BY dept_name 
                ORDER BY total_revenue DESC
            ) AS revenue_rank,
            ROW_NUMBER() OVER (
                PARTITION BY dept_name 
                ORDER BY project_count DESC
            ) AS project_rank
        FROM combined_metrics
    )
    
-- Final output
SELECT 
    emp_name,
    dept_name,
    salary,
    total_revenue,
    total_sales,
    project_count,
    performance_category,
    revenue_rank,
    project_rank
FROM dept_rankings
WHERE performance_category = 'High Performer'
   OR revenue_rank <= 3
ORDER BY dept_name, revenue_rank;
```

## 4. Recursive Queries for Hierarchies

### Problem: Organizational hierarchy (managers and subordinates)

```sql
-- Get full management chain
WITH RECURSIVE org_hierarchy AS (
    -- Anchor: Top-level managers (no manager)
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        0 AS level,
        CAST(emp_name AS VARCHAR(500)) AS hierarchy_path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive: Find direct reports
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        oh.level + 1,
        CAST(oh.hierarchy_path || ' > ' || e.emp_name AS VARCHAR(500))
    FROM employees e
    INNER JOIN org_hierarchy oh ON e.manager_id = oh.emp_id
)
SELECT 
    emp_name,
    level,
    hierarchy_path
FROM org_hierarchy
ORDER BY level, emp_name;
```

### Problem: Find all subordinates of a manager

```sql
WITH RECURSIVE subordinates AS (
    -- Start with specific manager
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        0 AS level
    FROM employees
    WHERE emp_id = 1  -- Manager ID
    
    UNION ALL
    
    -- Recursive: Find all reports
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        s.level + 1
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.emp_id
)
SELECT 
    emp_name,
    level,
    CASE 
        WHEN level = 0 THEN 'Manager'
        WHEN level = 1 THEN 'Direct Report'
        ELSE 'Indirect Report (Level ' || level || ')'
    END AS relationship
FROM subordinates
ORDER BY level, emp_name;
```

## 5. Pivot and Unpivot Operations

### Problem: Pivot sales data by region

```sql
-- Using conditional aggregation (works in all databases)
SELECT 
    emp_name,
    SUM(CASE WHEN region = 'North' THEN amount ELSE 0 END) AS north_sales,
    SUM(CASE WHEN region = 'South' THEN amount ELSE 0 END) AS south_sales,
    SUM(CASE WHEN region = 'East' THEN amount ELSE 0 END) AS east_sales,
    SUM(CASE WHEN region = 'West' THEN amount ELSE 0 END) AS west_sales,
    SUM(amount) AS total_sales
FROM sales s
INNER JOIN employees e ON s.emp_id = e.emp_id
GROUP BY emp_name;
```

### Problem: Monthly sales pivot

```sql
SELECT 
    emp_name,
    SUM(CASE WHEN EXTRACT(MONTH FROM sale_date) = 1 THEN amount ELSE 0 END) AS jan,
    SUM(CASE WHEN EXTRACT(MONTH FROM sale_date) = 2 THEN amount ELSE 0 END) AS feb,
    SUM(CASE WHEN EXTRACT(MONTH FROM sale_date) = 3 THEN amount ELSE 0 END) AS mar,
    SUM(CASE WHEN EXTRACT(MONTH FROM sale_date) = 4 THEN amount ELSE 0 END) AS apr,
    SUM(CASE WHEN EXTRACT(MONTH FROM sale_date) = 5 THEN amount ELSE 0 END) AS may,
    SUM(CASE WHEN EXTRACT(MONTH FROM sale_date) = 6 THEN amount ELSE 0 END) AS jun,
    SUM(amount) AS total
FROM sales s
INNER JOIN employees e ON s.emp_id = e.emp_id
WHERE EXTRACT(YEAR FROM sale_date) = 2024
GROUP BY emp_name;
```

## 6. Time-Based Analysis

### Problem: Month-over-month growth

```sql
WITH monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', sale_date) AS month,
        SUM(amount) AS monthly_revenue,
        COUNT(*) AS sale_count
    FROM sales
    GROUP BY DATE_TRUNC('month', sale_date)
),
growth_analysis AS (
    SELECT 
        month,
        monthly_revenue,
        LAG(monthly_revenue, 1) OVER (ORDER BY month) AS prev_month_revenue,
        LAG(monthly_revenue, 12) OVER (ORDER BY month) AS prev_year_revenue,
        monthly_revenue - LAG(monthly_revenue, 1) OVER (ORDER BY month) AS mom_growth,
        monthly_revenue - LAG(monthly_revenue, 12) OVER (ORDER BY month) AS yoy_growth
    FROM monthly_sales
)
SELECT 
    TO_CHAR(month, 'YYYY-MM') AS month,
    monthly_revenue,
    prev_month_revenue,
    ROUND(mom_growth, 2) AS mom_growth,
    ROUND(
        100.0 * mom_growth / NULLIF(prev_month_revenue, 0),
        2
    ) AS mom_growth_pct,
    ROUND(yoy_growth, 2) AS yoy_growth,
    ROUND(
        100.0 * yoy_growth / NULLIF(prev_year_revenue, 0),
        2
    ) AS yoy_growth_pct
FROM growth_analysis
ORDER BY month;
```

### Problem: Running totals and moving averages

```sql
SELECT 
    sale_date,
    amount,
    -- Running total
    SUM(amount) OVER (
        ORDER BY sale_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total,
    -- 7-day moving average
    AVG(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7d,
    -- 30-day moving average
    AVG(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_avg_30d
FROM sales
ORDER BY sale_date;
```

## 7. Finding Gaps and Islands

### Problem: Find missing employee IDs

```sql
WITH numbered_ids AS (
    SELECT 
        emp_id,
        ROW_NUMBER() OVER (ORDER BY emp_id) AS rn
    FROM employees
),
gaps AS (
    SELECT 
        n1.emp_id + 1 AS gap_start,
        n2.emp_id - 1 AS gap_end
    FROM numbered_ids n1
    JOIN numbered_ids n2 ON n1.rn = n2.rn - 1
    WHERE n2.emp_id - n1.emp_id > 1
)
SELECT 
    gap_start,
    gap_end,
    gap_end - gap_start + 1 AS gap_size
FROM gaps;
```

### Problem: Find consecutive date ranges (islands)

```sql
-- Find consecutive days with sales
WITH sales_dates AS (
    SELECT DISTINCT sale_date
    FROM sales
    ORDER BY sale_date
),
date_groups AS (
    SELECT 
        sale_date,
        sale_date - ROW_NUMBER() OVER (ORDER BY sale_date)::INTEGER AS grp
    FROM sales_dates
)
SELECT 
    MIN(sale_date) AS island_start,
    MAX(sale_date) AS island_end,
    COUNT(*) AS consecutive_days
FROM date_groups
GROUP BY grp
ORDER BY island_start;
```

## 8. Top N Per Group Problems

### Problem: Top 3 earners in each department

```sql
WITH ranked_employees AS (
    SELECT 
        e.emp_name,
        d.dept_name,
        e.salary,
        ROW_NUMBER() OVER (
            PARTITION BY d.dept_id 
            ORDER BY e.salary DESC
        ) AS salary_rank
    FROM employees e
    INNER JOIN departments d ON e.department_id = d.dept_id
)
SELECT 
    emp_name,
    dept_name,
    salary,
    salary_rank
FROM ranked_employees
WHERE salary_rank <= 3
ORDER BY dept_name, salary_rank;
```

### Problem: Employees with highest sales in each region

```sql
WITH regional_sales AS (
    SELECT 
        e.emp_name,
        s.region,
        SUM(s.amount) AS total_sales,
        RANK() OVER (
            PARTITION BY s.region 
            ORDER BY SUM(s.amount) DESC
        ) AS sales_rank
    FROM sales s
    INNER JOIN employees e ON s.emp_id = e.emp_id
    GROUP BY e.emp_name, s.region
)
SELECT 
    region,
    emp_name,
    total_sales,
    sales_rank
FROM regional_sales
WHERE sales_rank = 1
ORDER BY region;
```

## 9. Self-Joins for Comparisons

### Problem: Find employees with similar salaries

```sql
SELECT 
    e1.emp_name AS employee1,
    e2.emp_name AS employee2,
    e1.salary AS salary1,
    e2.salary AS salary2,
    ABS(e1.salary - e2.salary) AS salary_difference
FROM employees e1
INNER JOIN employees e2 
    ON e1.department_id = e2.department_id
    AND e1.emp_id < e2.emp_id  -- Avoid duplicates and self-joins
WHERE ABS(e1.salary - e2.salary) <= 5000
ORDER BY salary_difference;
```

### Problem: Find employees hired within 30 days of each other

```sql
SELECT 
    e1.emp_name AS employee1,
    e2.emp_name AS employee2,
    e1.hire_date AS hire_date1,
    e2.hire_date AS hire_date2,
    ABS(e1.hire_date - e2.hire_date) AS days_difference
FROM employees e1
INNER JOIN employees e2 
    ON e1.department_id = e2.department_id
    AND e1.emp_id < e2.emp_id
WHERE ABS(e1.hire_date - e2.hire_date) <= 30
ORDER BY days_difference;
```

## 10. Conditional Aggregations

### Problem: Multiple conditions in one query

```sql
SELECT 
    d.dept_name,
    COUNT(*) AS total_employees,
    COUNT(CASE WHEN e.salary > 60000 THEN 1 END) AS high_earners,
    COUNT(CASE WHEN e.salary BETWEEN 50000 AND 60000 THEN 1 END) AS mid_earners,
    COUNT(CASE WHEN e.salary < 50000 THEN 1 END) AS low_earners,
    SUM(CASE WHEN e.hire_date >= '2020-01-01' THEN 1 ELSE 0 END) AS recent_hires,
    AVG(e.salary) AS avg_salary,
    MAX(e.salary) AS max_salary
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.department_id
GROUP BY d.dept_name
ORDER BY total_employees DESC;
```

## 11. Complex Filtering with Multiple Criteria

### Problem: Employees meeting multiple conditions

```sql
WITH employee_metrics AS (
    SELECT 
        e.emp_id,
        e.emp_name,
        e.salary,
        d.dept_name,
        COUNT(DISTINCT s.sale_id) AS sale_count,
        COALESCE(SUM(s.amount), 0) AS total_sales,
        COUNT(DISTINCT ep.project_id) AS project_count
    FROM employees e
    INNER JOIN departments d ON e.department_id = d.dept_id
    LEFT JOIN sales s ON e.emp_id = s.emp_id
    LEFT JOIN employee_projects ep ON e.emp_id = ep.emp_id
    GROUP BY e.emp_id, e.emp_name, e.salary, d.dept_name
)
SELECT 
    emp_name,
    dept_name,
    salary,
    sale_count,
    total_sales,
    project_count,
    CASE 
        WHEN salary > 60000 
             AND total_sales > 100000 
             AND project_count >= 2 
        THEN 'Star Performer'
        WHEN (salary > 60000 AND total_sales > 100000)
             OR (total_sales > 100000 AND project_count >= 2)
        THEN 'High Performer'
        ELSE 'Standard'
    END AS performance_tier
FROM employee_metrics
WHERE salary > 60000 
   OR total_sales > 100000 
   OR project_count >= 2
ORDER BY performance_tier, total_sales DESC;
```

## 12. Data Quality and Validation Queries

### Problem: Find data quality issues

```sql
WITH validation_checks AS (
    SELECT 
        'Missing Name' AS issue_type,
        COUNT(*) AS issue_count
    FROM employees
    WHERE emp_name IS NULL OR TRIM(emp_name) = ''
    
    UNION ALL
    
    SELECT 
        'Missing Department' AS issue_type,
        COUNT(*) AS issue_count
    FROM employees
    WHERE department_id IS NULL
    
    UNION ALL
    
    SELECT 
        'Invalid Salary' AS issue_type,
        COUNT(*) AS issue_count
    FROM employees
    WHERE salary IS NULL OR salary <= 0
    
    UNION ALL
    
    SELECT 
        'Future Hire Date' AS issue_type,
        COUNT(*) AS issue_count
    FROM employees
    WHERE hire_date > CURRENT_DATE
    
    UNION ALL
    
    SELECT 
        'Duplicate Names' AS issue_type,
        COUNT(*) - COUNT(DISTINCT emp_name) AS issue_count
    FROM employees
    WHERE emp_name IS NOT NULL
)
SELECT 
    issue_type,
    issue_count,
    CASE 
        WHEN issue_count = 0 THEN '✓ OK'
        WHEN issue_count < 5 THEN '⚠ Warning'
        ELSE '✗ Critical'
    END AS status
FROM validation_checks
ORDER BY issue_count DESC;
```

## 13. Performance Optimization Tips

### 1. Use CTEs for readability, but be aware of performance
```sql
-- Good: CTE for complex logic
WITH complex_calc AS (...)
SELECT * FROM complex_calc;

-- Consider: Sometimes subquery might be faster
-- Test both approaches
```

### 2. Index columns used in JOINs and WHERE clauses
```sql
CREATE INDEX idx_dept_id ON employees(department_id);
CREATE INDEX idx_sale_date ON sales(sale_date);
CREATE INDEX idx_emp_sale ON sales(emp_id, sale_date);
```

### 3. Filter early, aggregate late
```sql
-- Bad: Aggregate then filter
SELECT * FROM (
    SELECT dept_id, AVG(salary) FROM employees GROUP BY dept_id
) WHERE avg > 50000;

-- Good: Filter first
SELECT dept_id, AVG(salary) 
FROM employees 
WHERE salary > 30000
GROUP BY dept_id
HAVING AVG(salary) > 50000;
```

### 4. Use EXPLAIN to analyze query plans
```sql
EXPLAIN ANALYZE
SELECT ... -- Your complex query
```

## Key Takeaways

1. **Break complex queries into CTEs** - Makes them readable and debuggable
2. **Use window functions** - For rankings, running totals, comparisons
3. **Recursive CTEs** - Essential for hierarchical data
4. **Correlated subqueries** - When you need row-by-row comparisons
5. **Self-joins** - For comparing rows within the same table
6. **Conditional aggregation** - Use CASE in aggregations
7. **Test incrementally** - Build and test each CTE separately
8. **Index strategically** - On JOIN and WHERE columns
9. **Filter early** - Reduce data before complex operations
10. **Document complex logic** - Add comments explaining the business logic

## Common Patterns

- **Multi-step analysis**: CTE1 → CTE2 → CTE3 → Final SELECT
- **Hierarchical data**: Recursive CTEs
- **Time series**: Window functions with LAG/LEAD
- **Top N per group**: ROW_NUMBER() with PARTITION BY
- **Gaps and islands**: ROW_NUMBER() with date arithmetic
- **Pivoting**: CASE statements in aggregations
- **Data quality**: UNION ALL with validation checks

