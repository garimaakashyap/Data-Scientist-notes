# SQL Window Functions - Complete Guide

## What are Window Functions?
Window functions perform calculations across a set of rows related to the current row, without collapsing rows into groups. Unlike aggregate functions with GROUP BY, window functions return a value for each row.

## Key Difference: Aggregate vs Window Functions

```sql
-- AGGREGATE FUNCTION (collapses rows)
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id;
-- Result: One row per department

-- WINDOW FUNCTION (keeps all rows)
SELECT 
    emp_name,
    salary,
    AVG(salary) OVER (PARTITION BY department_id) AS dept_avg_salary
FROM employees;
-- Result: All rows with average added
```

## Basic Syntax

```sql
window_function() OVER (
    [PARTITION BY column1, column2, ...]
    [ORDER BY column1 [ASC|DESC], ...]
    [ROWS/RANGE BETWEEN ...]
)
```

## Sample Data

```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    department_id INT,
    salary DECIMAL(10,2),
    hire_date DATE
);

INSERT INTO employees VALUES
(1, 'Alice', 10, 50000, '2020-01-15'),
(2, 'Bob', 10, 60000, '2019-03-20'),
(3, 'Charlie', 10, 55000, '2021-06-10'),
(4, 'Diana', 20, 70000, '2018-11-05'),
(5, 'Eve', 20, 65000, '2020-09-12'),
(6, 'Frank', 20, 60000, '2022-01-08'),
(7, 'Grace', 30, 80000, '2017-05-22'),
(8, 'Henry', 30, 75000, '2019-08-30');
```

## 1. Ranking Functions

### ROW_NUMBER()
Assigns a unique sequential number to each row within a partition.

```sql
SELECT 
    emp_name,
    department_id,
    salary,
    ROW_NUMBER() OVER (
        PARTITION BY department_id 
        ORDER BY salary DESC
    ) AS salary_rank
FROM employees;

-- Result:
-- emp_name | dept_id | salary | salary_rank
-- Bob      | 10      | 60000  | 1
-- Charlie  | 10      | 55000  | 2
-- Alice    | 10      | 50000  | 3
-- Diana    | 20      | 70000  | 1
-- Eve      | 20      | 65000  | 2
-- Frank    | 20      | 60000  | 3
-- Grace    | 30      | 80000  | 1
-- Henry    | 30      | 75000  | 2
```

**Use case:** Get top N records per group, remove duplicates.

### RANK()
Assigns rank with gaps (ties get same rank, next rank is skipped).

```sql
SELECT 
    emp_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- If two people have same salary, they get same rank
-- Next rank is skipped
-- Example: 1, 2, 2, 4 (not 1, 2, 2, 3)
```

### DENSE_RANK()
Assigns rank without gaps (ties get same rank, next rank continues).

```sql
SELECT 
    emp_name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- If two people have same salary, they get same rank
-- Next rank continues (no gap)
-- Example: 1, 2, 2, 3 (not 1, 2, 2, 4)
```

### Comparison Example

```sql
-- Employees with same salary
INSERT INTO employees VALUES (9, 'Ivy', 10, 60000, '2021-02-14');

SELECT 
    emp_name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num,
    RANK() OVER (ORDER BY salary DESC) AS rank_val,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS dense_rank_val
FROM employees
WHERE department_id = 10
ORDER BY salary DESC;

-- Result:
-- emp_name | salary | row_num | rank_val | dense_rank_val
-- Bob      | 60000  | 1       | 1        | 1
-- Ivy      | 60000  | 2       | 1        | 1
-- Charlie  | 55000  | 3       | 3        | 2  ← Notice the difference!
-- Alice    | 50000  | 4       | 4        | 3
```

### PERCENT_RANK()
Returns relative rank as a percentage (0 to 1).

```sql
SELECT 
    emp_name,
    salary,
    PERCENT_RANK() OVER (ORDER BY salary) AS percent_rank
FROM employees;

-- 0.0 = lowest salary
-- 1.0 = highest salary
-- 0.5 = median salary
```

### NTILE()
Divides rows into a specified number of groups (buckets).

```sql
-- Divide employees into 3 salary groups
SELECT 
    emp_name,
    salary,
    NTILE(3) OVER (ORDER BY salary DESC) AS salary_tier
FROM employees;

-- Result: 1 = top third, 2 = middle third, 3 = bottom third
```

## 2. Aggregate Window Functions

### SUM() OVER()
```sql
-- Running total
SELECT 
    emp_name,
    salary,
    SUM(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM employees
ORDER BY hire_date;

-- Result shows cumulative sum as you go down the list
```

### AVG() OVER()
```sql
-- Moving average (last 3 rows)
SELECT 
    emp_name,
    salary,
    AVG(salary) OVER (
        ORDER BY hire_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3
FROM employees
ORDER BY hire_date;
```

### COUNT() OVER()
```sql
-- Count employees in each department
SELECT 
    emp_name,
    department_id,
    COUNT(*) OVER (PARTITION BY department_id) AS dept_employee_count
FROM employees;
```

### MIN() / MAX() OVER()
```sql
-- Compare each salary to department min/max
SELECT 
    emp_name,
    department_id,
    salary,
    MIN(salary) OVER (PARTITION BY department_id) AS dept_min_salary,
    MAX(salary) OVER (PARTITION BY department_id) AS dept_max_salary,
    salary - MIN(salary) OVER (PARTITION BY department_id) AS above_min
FROM employees;
```

## 3. Value Functions

### LAG()
Accesses data from a previous row.

```sql
-- Compare current salary to previous employee's salary
SELECT 
    emp_name,
    salary,
    LAG(salary, 1) OVER (ORDER BY hire_date) AS prev_salary,
    salary - LAG(salary, 1) OVER (ORDER BY hire_date) AS salary_diff
FROM employees
ORDER BY hire_date;

-- LAG(salary, 2) would get salary from 2 rows before
-- LAG(salary, 1, 0) would default to 0 if no previous row
```

### LEAD()
Accesses data from a following row.

```sql
-- Compare current salary to next employee's salary
SELECT 
    emp_name,
    salary,
    LEAD(salary, 1) OVER (ORDER BY hire_date) AS next_salary
FROM employees
ORDER BY hire_date;
```

### FIRST_VALUE()
Returns the first value in the window.

```sql
-- First employee hired in each department
SELECT 
    emp_name,
    department_id,
    hire_date,
    FIRST_VALUE(emp_name) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
    ) AS first_employee
FROM employees;
```

### LAST_VALUE()
Returns the last value in the window.

```sql
-- Last employee hired in each department
SELECT 
    emp_name,
    department_id,
    hire_date,
    LAST_VALUE(emp_name) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_employee
FROM employees;
```

**Note:** LAST_VALUE() needs `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` to work correctly!

### NTH_VALUE()
Returns the value from the Nth row.

```sql
-- Second highest salary in each department
SELECT 
    emp_name,
    department_id,
    salary,
    NTH_VALUE(emp_name, 2) OVER (
        PARTITION BY department_id 
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS second_highest_earner
FROM employees;
```

## 4. Window Frame Specifications

### ROWS vs RANGE

**ROWS**: Physical rows
```sql
-- Last 2 rows
ROWS BETWEEN 2 PRECEDING AND CURRENT ROW

-- Next 2 rows
ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING

-- All rows before
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- All rows
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

**RANGE**: Logical range based on ORDER BY values
```sql
-- All rows with same or lower salary
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- Rows within ±1000 salary
RANGE BETWEEN 1000 PRECEDING AND 1000 FOLLOWING
```

### Common Frame Patterns

```sql
-- Running total (cumulative sum)
SUM(salary) OVER (
    ORDER BY hire_date 
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)

-- Moving average (last 3 rows)
AVG(salary) OVER (
    ORDER BY hire_date
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
)

-- Centered moving average (1 before, current, 1 after)
AVG(salary) OVER (
    ORDER BY hire_date
    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
)

-- All rows in partition
SUM(salary) OVER (
    PARTITION BY department_id
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

## 5. Practical Examples

### Example 1: Top N Per Group
```sql
-- Top 2 earners in each department
WITH ranked AS (
    SELECT 
        emp_name,
        department_id,
        salary,
        ROW_NUMBER() OVER (
            PARTITION BY department_id 
            ORDER BY salary DESC
        ) AS rn
    FROM employees
)
SELECT emp_name, department_id, salary
FROM ranked
WHERE rn <= 2;
```

### Example 2: Calculate Differences
```sql
-- Month-over-month growth
SELECT 
    month,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY month) AS prev_month_revenue,
    revenue - LAG(revenue, 1) OVER (ORDER BY month) AS growth,
    ROUND(
        100.0 * (revenue - LAG(revenue, 1) OVER (ORDER BY month)) 
        / LAG(revenue, 1) OVER (ORDER BY month), 
        2
    ) AS growth_percent
FROM monthly_sales;
```

### Example 3: Running Statistics
```sql
-- Running average and standard deviation
SELECT 
    emp_name,
    salary,
    hire_date,
    AVG(salary) OVER (
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_avg,
    STDDEV(salary) OVER (
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_stddev
FROM employees
ORDER BY hire_date;
```

### Example 4: Percentile Calculations
```sql
-- Salary percentile within department
SELECT 
    emp_name,
    department_id,
    salary,
    PERCENT_RANK() OVER (
        PARTITION BY department_id 
        ORDER BY salary
    ) AS percentile_rank,
    CASE 
        WHEN PERCENT_RANK() OVER (
            PARTITION BY department_id ORDER BY salary
        ) >= 0.9 THEN 'Top 10%'
        WHEN PERCENT_RANK() OVER (
            PARTITION BY department_id ORDER BY salary
        ) >= 0.75 THEN 'Top 25%'
        ELSE 'Below 75%'
    END AS salary_category
FROM employees;
```

### Example 5: Gaps and Islands Problem
```sql
-- Find gaps in sequences
WITH numbered AS (
    SELECT 
        id,
        ROW_NUMBER() OVER (ORDER BY id) AS rn
    FROM my_table
)
SELECT 
    n1.id + 1 AS gap_start,
    n2.id - 1 AS gap_end
FROM numbered n1
JOIN numbered n2 ON n1.rn = n2.rn - 1
WHERE n2.id - n1.id > 1;
```

## 6. Multiple Window Functions

```sql
-- Multiple window functions in one query
SELECT 
    emp_name,
    department_id,
    salary,
    -- Ranking
    ROW_NUMBER() OVER (
        PARTITION BY department_id 
        ORDER BY salary DESC
    ) AS dept_rank,
    -- Aggregates
    AVG(salary) OVER (PARTITION BY department_id) AS dept_avg,
    MAX(salary) OVER (PARTITION BY department_id) AS dept_max,
    -- Running total
    SUM(salary) OVER (
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total,
    -- Comparison
    salary - LAG(salary, 1) OVER (ORDER BY hire_date) AS vs_prev
FROM employees;
```

## 7. Window Functions with CTEs

```sql
-- Complex analysis using CTEs and window functions
WITH 
    base_data AS (
        SELECT 
            emp_name,
            department_id,
            salary,
            hire_date
        FROM employees
    ),
    ranked_data AS (
        SELECT 
            *,
            ROW_NUMBER() OVER (
                PARTITION BY department_id 
                ORDER BY salary DESC
            ) AS salary_rank,
            AVG(salary) OVER (PARTITION BY department_id) AS dept_avg
        FROM base_data
    ),
    analysis AS (
        SELECT 
            *,
            salary - dept_avg AS diff_from_avg,
            CASE 
                WHEN salary_rank = 1 THEN 'Top Earner'
                WHEN salary > dept_avg THEN 'Above Average'
                ELSE 'Below Average'
            END AS category
        FROM ranked_data
    )
SELECT 
    emp_name,
    department_id,
    salary,
    salary_rank,
    ROUND(diff_from_avg, 2) AS diff_from_avg,
    category
FROM analysis
ORDER BY department_id, salary_rank;
```

## 8. Performance Tips

### 1. Use PARTITION BY efficiently
```sql
-- Good: Partition by indexed column
SELECT 
    *,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary)
FROM employees;
-- (department_id should be indexed)
```

### 2. Avoid unnecessary window functions
```sql
-- Bad: Calculating same thing multiple times
SELECT 
    *,
    AVG(salary) OVER (PARTITION BY dept) AS avg1,
    AVG(salary) OVER (PARTITION BY dept) AS avg2,
    AVG(salary) OVER (PARTITION BY dept) AS avg3
FROM employees;

-- Good: Use CTE
WITH dept_avg AS (
    SELECT 
        *,
        AVG(salary) OVER (PARTITION BY dept) AS avg_salary
    FROM employees
)
SELECT 
    *,
    avg_salary AS avg1,
    avg_salary AS avg2,
    avg_salary AS avg3
FROM dept_avg;
```

### 3. Index ORDER BY columns
```sql
-- If you ORDER BY hire_date in window function,
-- index hire_date for better performance
CREATE INDEX idx_hire_date ON employees(hire_date);
```

## 9. Common Mistakes

### Mistake 1: Forgetting PARTITION BY
```sql
-- WRONG: Gets overall rank, not per department
SELECT 
    emp_name,
    department_id,
    ROW_NUMBER() OVER (ORDER BY salary) AS rank
FROM employees;

-- CORRECT: Rank within each department
SELECT 
    emp_name,
    department_id,
    ROW_NUMBER() OVER (
        PARTITION BY department_id 
        ORDER BY salary
    ) AS rank
FROM employees;
```

### Mistake 2: LAST_VALUE() without proper frame
```sql
-- WRONG: Doesn't work as expected
SELECT 
    LAST_VALUE(emp_name) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
    )
FROM employees;

-- CORRECT: Need UNBOUNDED FOLLOWING
SELECT 
    LAST_VALUE(emp_name) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    )
FROM employees;
```

### Mistake 3: Using window function in WHERE
```sql
-- WRONG: Can't use window function in WHERE
SELECT * FROM employees
WHERE ROW_NUMBER() OVER (...) <= 5;

-- CORRECT: Use CTE or subquery
WITH ranked AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (...) AS rn
    FROM employees
)
SELECT * FROM ranked WHERE rn <= 5;
```

## 10. Real-World Use Cases

### Use Case 1: Customer Lifetime Value
```sql
-- Calculate running total of customer purchases
SELECT 
    customer_id,
    purchase_date,
    amount,
    SUM(amount) OVER (
        PARTITION BY customer_id 
        ORDER BY purchase_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS lifetime_value
FROM purchases;
```

### Use Case 2: Time Series Analysis
```sql
-- 7-day moving average
SELECT 
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7d
FROM daily_metrics;
```

### Use Case 3: Cohort Analysis
```sql
-- Days since first purchase
SELECT 
    customer_id,
    purchase_date,
    FIRST_VALUE(purchase_date) OVER (
        PARTITION BY customer_id 
        ORDER BY purchase_date
    ) AS first_purchase_date,
    purchase_date - FIRST_VALUE(purchase_date) OVER (
        PARTITION BY customer_id 
        ORDER BY purchase_date
    ) AS days_since_first
FROM purchases;
```

## Key Takeaways

1. **Window functions keep all rows** - Unlike GROUP BY
2. **PARTITION BY** - Divides data into groups
3. **ORDER BY** - Determines order within partition
4. **Frame specification** - Defines which rows to include
5. **ROW_NUMBER()** - Unique sequential numbers
6. **RANK()** - Rank with gaps for ties
7. **DENSE_RANK()** - Rank without gaps
8. **LAG/LEAD** - Access previous/next rows
9. **Aggregate functions** - SUM, AVG, COUNT, etc. work as window functions
10. **Performance** - Index columns used in PARTITION BY and ORDER BY

## Quick Reference

```
RANKING:
- ROW_NUMBER() → 1, 2, 3, 4, 5
- RANK() → 1, 2, 2, 4, 5 (gaps)
- DENSE_RANK() → 1, 2, 2, 3, 4 (no gaps)

VALUE:
- LAG(column, n) → Previous row
- LEAD(column, n) → Next row
- FIRST_VALUE() → First in window
- LAST_VALUE() → Last in window

AGGREGATE:
- SUM/AVG/COUNT/MIN/MAX OVER()

FRAME:
- ROWS BETWEEN ... AND ...
- RANGE BETWEEN ... AND ...
- UNBOUNDED PRECEDING/FOLLOWING
```

